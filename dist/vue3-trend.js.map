{"version":3,"file":"vue3-trend.js","sources":["../src/helpers/math.ts","../src/helpers/path.ts","../src/components/TrendGradient.vue","../src/components/TrendPath.vue","../src/components/VueTrend.vue","../src/index.ts"],"sourcesContent":["export interface Point {\n  x: number\n  y: number\n}\n\n// Using parseInt for checking collinearity might lead to precision issues\n// with floating-point numbers. Comparing floating points directly for equality\n// is generally discouraged. Using a small tolerance (epsilon) is better,\n// or checking if the slope is the same. However, the original logic used parseInt.\n// Let's keep the core logic but acknowledge this potential issue.\nfunction int(value: number): number {\n  // Original used parseInt, which truncates. Math.round might be slightly better\n  // if the intention was to compare visually close points on a pixel grid.\n  // Let's stick to parseInt to maintain original behavior.\n  return parseInt(value.toString(), 10)\n}\n\n/**\n * Checks if three points are collinear (lie on the same straight line).\n * https://en.wikipedia.org/wiki/Collinearity\n * It checks if the midpoint of p0 and p2 is approximately equal to p1.\n * Note: Uses integer comparison, which might have precision issues.\n * @param {Point} p0 - The first point.\n * @param {Point} p1 - The second point (middle).\n * @param {Point} p2 - The third point.\n * @returns {boolean} True if the points are collinear, false otherwise.\n */\nexport function checkCollinear(p0: Point, p1: Point, p2: Point): boolean {\n  // Avoid division by zero if points are identical\n  if ((p0.x === p1.x && p0.y === p1.y) || (p1.x === p2.x && p1.y === p2.y)) {\n    return true\n  }\n  // Original check using integer comparison\n  return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y)\n  // Alternative check using slope (more robust for floats, handles vertical lines):\n  // const slope1 = (p1.y - p0.y) * (p2.x - p1.x);\n  // const slope2 = (p2.y - p1.y) * (p1.x - p0.x);\n  // return Math.abs(slope1 - slope2) < 1e-9; // Using a small epsilon\n}\n\n/**\n * Calculates the Euclidean distance between two points.\n * @param {Point} p1 - The first point.\n * @param {Point} p2 - The second point.\n * @returns {number} The distance between the two points.\n */\nexport function getDistance(p1: Point, p2: Point): number {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n/**\n * Calculates a point on the line segment between 'from' and 'to',\n * at a specified distance ('radius') from the 'from' point.\n * @param {Point} to - The target point.\n * @param {Point} from - The starting point.\n * @param {number} radius - The distance from the 'from' point.\n * @returns {Point} The calculated point.\n */\nexport function moveTo(to: Point, from: Point, radius: number): Point {\n  const vector = { x: to.x - from.x, y: to.y - from.y }\n  const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y)\n\n  // Handle case where points are identical to avoid division by zero\n  if (length === 0) {\n    return { ...from } // Return the starting point\n  }\n\n  const unitVector = { x: vector.x / length, y: vector.y / length }\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius,\n  }\n}\n","import { checkCollinear, getDistance, moveTo, type Point } from './math'\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface PointOptions {\n  max: number\n  min: number\n}\n\nexport type InputData = number | { value: number }\n\n/**\n *  Calculate the coordinate\n * @param  {InputData[]} arr\n * @param  {Boundary} boundary\n * @param  {PointOptions} limits\n * @return {Point[]}\n */\nexport function genPoints(\n  arr: InputData[],\n  { minX, minY, maxX, maxY }: Boundary,\n  { max, min }: PointOptions,\n): Point[] {\n  const values: number[] = arr.map((item) => (typeof item === 'number' ? item : item.value))\n  const minValue = Math.min(...values, min) - 0.001\n  const maxValue = Math.max(...values, max) + 0.001\n  const gridX = (maxX - minX) / (values.length - 1)\n  const gridY = (maxY - minY) / (maxValue - minValue)\n\n  // Prevent division by zero if all values are the same\n  const safeGridY = Number.isFinite(gridY) ? gridY : 0\n\n  return values.map((value, index) => {\n    return {\n      x: index * gridX + minX,\n      y:\n        maxY -\n        (value - minValue) * safeGridY +\n        // Need these small adjustments to prevent floating point issues\n        // causing the path to not be perfectly horizontal when all values are equal.\n        // Also ensures the path starts and ends exactly at the boundaries.\n        (index === values.length - 1 ? -0.00001 : 0) +\n        (index === 0 ? 0.00001 : 0),\n\n      // Original logic - might have issues with perfectly flat lines\n      // maxY -\n      // (value - minValue) * gridY +\n      // +(index === arr.length - 1) * 0.00001 -\n      // +(index === 0) * 0.00001\n    }\n  })\n}\n\n/**\n * From https://github.com/unsplash/react-trend/blob/master/src/helpers/DOM.helpers.js#L18\n * Generates the SVG path data string (d attribute).\n * @param {Point[]} points - The array of points (coordinates).\n * @param {number} radius - The radius for smoothing corners.\n * @returns {string} The SVG path data string.\n */\nexport function genPath(points: Point[], radius: number): string {\n  if (points.length < 2) {\n    return ''\n  }\n  // Clone points array to avoid modifying the original\n  const pts = [...points]\n  const start = pts.shift()! // Non-null assertion as we checked length >= 2\n\n  return (\n    `M${start.x} ${start.y}` +\n    pts\n      .map((point, index) => {\n        const next = pts[index + 1]\n        const prev = pts[index - 1] || start\n        const isCollinear = next && checkCollinear(prev, point, next) // Check using prev, current, next\n\n        if (!next || isCollinear) {\n          return `L${point.x} ${point.y}`\n        }\n\n        const threshold = Math.min(getDistance(prev, point), getDistance(next, point))\n        // Avoid radius larger than half the distance to the previous/next point\n        const radiusForPoint = Math.min(radius, threshold / 2)\n        // Original logic: const isTooCloseForRadius = threshold / 2 < radius\n        // Original logic: const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius\n\n        const before = moveTo(prev, point, radiusForPoint)\n        const after = moveTo(next, point, radiusForPoint)\n\n        return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`\n      })\n      .join('')\n  )\n}\n","<template>\n  <defs>\n    <linearGradient :id=\"props.id\" :x1=\"x1\" :y1=\"y1\" :x2=\"x2\" :y2=\"y2\">\n      <stop\n        v-for=\"(color, index) in reversedGradient\"\n        :key=\"index\"\n        :offset=\"calculateOffset(index)\"\n        :stop-color=\"color\"\n      />\n    </linearGradient>\n  </defs>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\n\n// Define type alias for gradient direction\nexport type GradientDirection = 'top' | 'bottom' | 'left' | 'right'\n\nexport interface Props {\n  gradient?: string[]\n  gradientDirection?: GradientDirection\n  id: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  gradient: () => ['#000'],\n  gradientDirection: 'top'\n})\n\n// Compute reversed gradient array for v-for\nconst reversedGradient = computed(() => {\n  // Ensure gradient is always an array, provide default if needed\n  return [...props.gradient].reverse() // Use spread syntax for shallow clone before reversing\n})\n\n// Calculate gradient direction coordinates\nconst x1 = computed(() => +(props.gradientDirection === 'left'))\nconst y1 = computed(() => +(props.gradientDirection === 'top'))\nconst x2 = computed(() => +(props.gradientDirection === 'right'))\nconst y2 = computed(() => +(props.gradientDirection === 'bottom'))\n\n// Calculate stop offset\nconst calculateOffset = (index: number): number => {\n  const len = reversedGradient.value.length - 1 || 1\n  return index / len\n}\n</script>\n","<template>\n  <path :d=\"pathData\" fill=\"none\" :stroke=\"strokeUrl\" />\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { genPath, genPoints, type Boundary, type InputData } from '../helpers/path'\n\nexport interface Props {\n  data: InputData[]\n  boundary: Boundary\n  id: string\n  smooth?: boolean\n  radius?: number\n  max?: number\n  min?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  smooth: false,\n  radius: 10,\n  max: -Infinity,\n  min: Infinity\n})\n\n// Computed property for the path data 'd' attribute\nconst pathData = computed(() => {\n  if (!props.data || props.data.length < 2) {\n    return '' // Return empty path if data is insufficient\n  }\n  const points = genPoints(props.data, props.boundary, { max: props.max, min: props.min })\n  return genPath(points, props.smooth ? props.radius : 0)\n})\n\n// Computed property for the stroke URL\nconst strokeUrl = computed(() => `url(#${props.id})`)\n</script>\n","<template>\n  <svg v-if=\"data && data.length >= 2\" :width :height :viewBox=\"`0 0 ${viewWidth} ${viewHeight}`\">\n    <TrendGradient :id=\"gradientId\" :gradient=\"gradient\" :gradient-direction=\"gradientDirection\" />\n    <TrendPath\n      ref=\"pathRef\"\n      :data=\"data\"\n      :boundary=\"boundary\"\n      :smooth=\"smooth\"\n      :radius=\"radius\"\n      :id=\"gradientId\"\n      :max=\"max\"\n      :min=\"min\"\n    />\n  </svg>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, ref, watch } from 'vue'\nimport { type Boundary, type InputData } from '../helpers/path'\nimport TrendGradient, { type GradientDirection } from './TrendGradient.vue'\nimport TrendPath from './TrendPath.vue'\n\nexport interface Props {\n  data: InputData[]\n  autoDraw?: boolean\n  autoDrawDuration?: number\n  autoDrawEasing?: string\n  gradient?: string[]\n  gradientDirection?: GradientDirection\n  max?: number\n  min?: number\n  height?: number | string\n  width?: number | string\n  viewHeight?: number\n  viewWidth?: number\n  padding?: number\n  radius?: number\n  smooth?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  autoDraw: false,\n  autoDrawDuration: 2000,\n  autoDrawEasing: 'ease',\n  gradient: () => ['#000'], // Default factory for array\n  gradientDirection: 'top',\n  max: -Infinity,\n  min: Infinity,\n  height: '100%',\n  width: '100%',\n  viewHeight: 75,\n  viewWidth: 300,\n  padding: 8,\n  radius: 10,\n  smooth: false\n  // Default width/height handled in computed properties if not provided\n})\n\n// Template refs\n// Specify the component type for better type checking\nconst pathRef = ref<InstanceType<typeof TrendPath> | null>(null)\n\n// Unique ID for gradient\nconst gradientId = computed(() => `vue-trend-${Math.random().toString(36).substring(7)}`)\n\nconst boundary = computed<Boundary>(() => ({\n  minX: props.padding,\n  minY: props.padding,\n  maxX: props.viewWidth - props.padding,\n  maxY: props.viewHeight - props.padding\n}))\n\n// Auto-draw animation logic\nconst lastLength = ref<number>(0) // Store the last path length for smooth transitions\n\nwatch(\n  () => props.data,\n  async (newData, oldData) => {\n    // Ensure data is actually new and autoDraw is enabled\n    // Comparing stringified versions is a simple way to check deep equality for basic data structures\n    if (props.autoDraw && JSON.stringify(newData) !== JSON.stringify(oldData)) {\n      await nextTick() // Wait for the DOM to update\n\n      // Check if running in server environment or if pathRef is not yet available\n      if (typeof window === 'undefined' || !pathRef.value?.$el) {\n        return\n      }\n\n      const pathElement = pathRef.value.$el as SVGPathElement // Type assertion\n      const length = pathElement.getTotalLength()\n\n      if (!isNaN(length)) {\n        // Ensure length is a valid number\n        pathElement.style.transition = 'none'\n        pathElement.style.strokeDasharray = `${length} ${length}`\n        // Use lastLength.value for the offset, default to 0 if it's the first draw\n        pathElement.style.strokeDashoffset = Math.abs(length - (lastLength.value || 0)).toString()\n\n        // Force reflow to apply the initial state before transition\n        pathElement.getBoundingClientRect()\n\n        // Apply the transition\n        pathElement.style.transition = `stroke-dashoffset ${props.autoDrawDuration}ms ${props.autoDrawEasing}`\n        pathElement.style.strokeDashoffset = '0'\n\n        lastLength.value = length // Update last length\n      } else {\n        console.warn('VueTrend: Could not get path length for autoDraw animation.')\n      }\n    } else if (!props.autoDraw && pathRef.value?.$el) {\n      // Reset styles if autoDraw is turned off\n      const pathElement = pathRef.value.$el as SVGPathElement\n      pathElement.style.transition = ''\n      pathElement.style.strokeDasharray = ''\n      pathElement.style.strokeDashoffset = ''\n      lastLength.value = 0 // Reset last length\n    }\n  },\n  {\n    immediate: true, // Run the watcher immediately on component mount\n    deep: true // Watch for changes within the data array/objects\n  }\n)\n</script>\n","import type { App, Plugin } from 'vue'\nimport VueTrendComponent from './components/VueTrend.vue'\n\nconst install: Plugin = (app: App) => {\n  app.component('VueTrend', VueTrendComponent)\n}\n\n// Attach the install function directly to the component object.\n// Use a type assertion with an intersection type to inform TypeScript\n// that this object now also has an 'install' property.\nconst VueTrend = VueTrendComponent as typeof VueTrendComponent & { install: Plugin }\nVueTrend.install = install\n\nexport default VueTrend\n"],"names":["int","value","checkCollinear","p0","p1","p2","getDistance","moveTo","to","from","radius","vector","length","unitVector","genPoints","arr","minX","minY","maxX","maxY","max","min","values","item","minValue","maxValue","gridX","gridY","safeGridY","index","genPath","points","pts","start","point","next","prev","isCollinear","threshold","radiusForPoint","before","after","props","__props","reversedGradient","computed","x1","y1","x2","y2","calculateOffset","len","pathData","strokeUrl","pathRef","ref","gradientId","boundary","lastLength","watch","newData","oldData","nextTick","_a","pathElement","_b","install","app","VueTrendComponent","VueTrend"],"mappings":"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"}