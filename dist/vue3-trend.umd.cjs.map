{"version":3,"file":"vue3-trend.umd.cjs","sources":["../src/helpers/math.ts","../src/helpers/path.ts","../src/components/TrendGradient.vue","../src/components/TrendPath.vue","../src/components/VueTrend.vue","../src/index.ts"],"sourcesContent":["export interface Point {\n  x: number\n  y: number\n}\n\n// Using parseInt for checking collinearity might lead to precision issues\n// with floating-point numbers. Comparing floating points directly for equality\n// is generally discouraged. Using a small tolerance (epsilon) is better,\n// or checking if the slope is the same. However, the original logic used parseInt.\n// Let's keep the core logic but acknowledge this potential issue.\nfunction int(value: number): number {\n  // Original used parseInt, which truncates. Math.round might be slightly better\n  // if the intention was to compare visually close points on a pixel grid.\n  // Let's stick to parseInt to maintain original behavior.\n  return parseInt(value.toString(), 10)\n}\n\n/**\n * Checks if three points are collinear (lie on the same straight line).\n * https://en.wikipedia.org/wiki/Collinearity\n * It checks if the midpoint of p0 and p2 is approximately equal to p1.\n * Note: Uses integer comparison, which might have precision issues.\n * @param {Point} p0 - The first point.\n * @param {Point} p1 - The second point (middle).\n * @param {Point} p2 - The third point.\n * @returns {boolean} True if the points are collinear, false otherwise.\n */\nexport function checkCollinear(p0: Point, p1: Point, p2: Point): boolean {\n  // Avoid division by zero if points are identical\n  if ((p0.x === p1.x && p0.y === p1.y) || (p1.x === p2.x && p1.y === p2.y)) {\n    return true\n  }\n  // Original check using integer comparison\n  return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y)\n  // Alternative check using slope (more robust for floats, handles vertical lines):\n  // const slope1 = (p1.y - p0.y) * (p2.x - p1.x);\n  // const slope2 = (p2.y - p1.y) * (p1.x - p0.x);\n  // return Math.abs(slope1 - slope2) < 1e-9; // Using a small epsilon\n}\n\n/**\n * Calculates the Euclidean distance between two points.\n * @param {Point} p1 - The first point.\n * @param {Point} p2 - The second point.\n * @returns {number} The distance between the two points.\n */\nexport function getDistance(p1: Point, p2: Point): number {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n/**\n * Calculates a point on the line segment between 'from' and 'to',\n * at a specified distance ('radius') from the 'from' point.\n * @param {Point} to - The target point.\n * @param {Point} from - The starting point.\n * @param {number} radius - The distance from the 'from' point.\n * @returns {Point} The calculated point.\n */\nexport function moveTo(to: Point, from: Point, radius: number): Point {\n  const vector = { x: to.x - from.x, y: to.y - from.y }\n  const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y)\n\n  // Handle case where points are identical to avoid division by zero\n  if (length === 0) {\n    return { ...from } // Return the starting point\n  }\n\n  const unitVector = { x: vector.x / length, y: vector.y / length }\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius,\n  }\n}\n","import { checkCollinear, getDistance, moveTo, type Point } from './math'\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface PointOptions {\n  max: number\n  min: number\n}\n\nexport type InputData = number | { value: number }\n\n/**\n *  Calculate the coordinate\n * @param  {InputData[]} arr\n * @param  {Boundary} boundary\n * @param  {PointOptions} limits\n * @return {Point[]}\n */\nexport function genPoints(\n  arr: InputData[],\n  { minX, minY, maxX, maxY }: Boundary,\n  { max, min }: PointOptions,\n): Point[] {\n  const values: number[] = arr.map((item) => (typeof item === 'number' ? item : item.value))\n  const minValue = Math.min(...values, min) - 0.001\n  const maxValue = Math.max(...values, max) + 0.001\n  const gridX = (maxX - minX) / (values.length - 1)\n  const gridY = (maxY - minY) / (maxValue - minValue)\n\n  // Prevent division by zero if all values are the same\n  const safeGridY = Number.isFinite(gridY) ? gridY : 0\n\n  return values.map((value, index) => {\n    return {\n      x: index * gridX + minX,\n      y:\n        maxY -\n        (value - minValue) * safeGridY +\n        // Need these small adjustments to prevent floating point issues\n        // causing the path to not be perfectly horizontal when all values are equal.\n        // Also ensures the path starts and ends exactly at the boundaries.\n        (index === values.length - 1 ? -0.00001 : 0) +\n        (index === 0 ? 0.00001 : 0),\n\n      // Original logic - might have issues with perfectly flat lines\n      // maxY -\n      // (value - minValue) * gridY +\n      // +(index === arr.length - 1) * 0.00001 -\n      // +(index === 0) * 0.00001\n    }\n  })\n}\n\n/**\n * From https://github.com/unsplash/react-trend/blob/master/src/helpers/DOM.helpers.js#L18\n * Generates the SVG path data string (d attribute).\n * @param {Point[]} points - The array of points (coordinates).\n * @param {number} radius - The radius for smoothing corners.\n * @returns {string} The SVG path data string.\n */\nexport function genPath(points: Point[], radius: number): string {\n  if (points.length < 2) {\n    return ''\n  }\n  // Clone points array to avoid modifying the original\n  const pts = [...points]\n  const start = pts.shift()! // Non-null assertion as we checked length >= 2\n\n  return (\n    `M${start.x} ${start.y}` +\n    pts\n      .map((point, index) => {\n        const next = pts[index + 1]\n        const prev = pts[index - 1] || start\n        const isCollinear = next && checkCollinear(prev, point, next) // Check using prev, current, next\n\n        if (!next || isCollinear) {\n          return `L${point.x} ${point.y}`\n        }\n\n        const threshold = Math.min(getDistance(prev, point), getDistance(next, point))\n        // Avoid radius larger than half the distance to the previous/next point\n        const radiusForPoint = Math.min(radius, threshold / 2)\n        // Original logic: const isTooCloseForRadius = threshold / 2 < radius\n        // Original logic: const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius\n\n        const before = moveTo(prev, point, radiusForPoint)\n        const after = moveTo(next, point, radiusForPoint)\n\n        return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`\n      })\n      .join('')\n  )\n}\n","<template>\n  <defs>\n    <linearGradient :id=\"props.id\" :x1=\"x1\" :y1=\"y1\" :x2=\"x2\" :y2=\"y2\">\n      <stop\n        v-for=\"(color, index) in reversedGradient\"\n        :key=\"index\"\n        :offset=\"calculateOffset(index)\"\n        :stop-color=\"color\"\n      />\n    </linearGradient>\n  </defs>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\n\n// Define type alias for gradient direction\nexport type GradientDirection = 'top' | 'bottom' | 'left' | 'right'\n\nexport interface Props {\n  gradient?: string[]\n  gradientDirection?: GradientDirection\n  id: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  gradient: () => ['#000'],\n  gradientDirection: 'top'\n})\n\n// Compute reversed gradient array for v-for\nconst reversedGradient = computed(() => {\n  // Ensure gradient is always an array, provide default if needed\n  return [...props.gradient].reverse() // Use spread syntax for shallow clone before reversing\n})\n\n// Calculate gradient direction coordinates\nconst x1 = computed(() => +(props.gradientDirection === 'left'))\nconst y1 = computed(() => +(props.gradientDirection === 'top'))\nconst x2 = computed(() => +(props.gradientDirection === 'right'))\nconst y2 = computed(() => +(props.gradientDirection === 'bottom'))\n\n// Calculate stop offset\nconst calculateOffset = (index: number): number => {\n  const len = reversedGradient.value.length - 1 || 1\n  return index / len\n}\n</script>\n","<template>\n  <path :d=\"pathData\" fill=\"none\" :stroke=\"strokeUrl\" />\n</template>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { genPath, genPoints, type Boundary, type InputData } from '../helpers/path'\n\nexport interface Props {\n  data: InputData[]\n  boundary: Boundary\n  id: string\n  smooth?: boolean\n  radius?: number\n  max?: number\n  min?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  smooth: false,\n  radius: 10,\n  max: -Infinity,\n  min: Infinity\n})\n\n// Computed property for the path data 'd' attribute\nconst pathData = computed(() => {\n  if (!props.data || props.data.length < 2) {\n    return '' // Return empty path if data is insufficient\n  }\n  const points = genPoints(props.data, props.boundary, { max: props.max, min: props.min })\n  return genPath(points, props.smooth ? props.radius : 0)\n})\n\n// Computed property for the stroke URL\nconst strokeUrl = computed(() => `url(#${props.id})`)\n</script>\n","<template>\n  <svg v-if=\"data && data.length >= 2\" :width :height :viewBox=\"`0 0 ${viewWidth} ${viewHeight}`\">\n    <TrendGradient :id=\"gradientId\" :gradient=\"gradient\" :gradient-direction=\"gradientDirection\" />\n    <TrendPath\n      ref=\"pathRef\"\n      :data=\"data\"\n      :boundary=\"boundary\"\n      :smooth=\"smooth\"\n      :radius=\"radius\"\n      :id=\"gradientId\"\n      :max=\"max\"\n      :min=\"min\"\n    />\n  </svg>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, ref, watch } from 'vue'\nimport { type Boundary, type InputData } from '../helpers/path'\nimport TrendGradient, { type GradientDirection } from './TrendGradient.vue'\nimport TrendPath from './TrendPath.vue'\n\nexport interface Props {\n  data: InputData[]\n  autoDraw?: boolean\n  autoDrawDuration?: number\n  autoDrawEasing?: string\n  gradient?: string[]\n  gradientDirection?: GradientDirection\n  max?: number\n  min?: number\n  height?: number | string\n  width?: number | string\n  viewHeight?: number\n  viewWidth?: number\n  padding?: number\n  radius?: number\n  smooth?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  autoDraw: false,\n  autoDrawDuration: 2000,\n  autoDrawEasing: 'ease',\n  gradient: () => ['#000'], // Default factory for array\n  gradientDirection: 'top',\n  max: -Infinity,\n  min: Infinity,\n  height: '100%',\n  width: '100%',\n  viewHeight: 75,\n  viewWidth: 300,\n  padding: 8,\n  radius: 10,\n  smooth: false\n  // Default width/height handled in computed properties if not provided\n})\n\n// Template refs\n// Specify the component type for better type checking\nconst pathRef = ref<InstanceType<typeof TrendPath> | null>(null)\n\n// Unique ID for gradient\nconst gradientId = computed(() => `vue-trend-${Math.random().toString(36).substring(7)}`)\n\nconst boundary = computed<Boundary>(() => ({\n  minX: props.padding,\n  minY: props.padding,\n  maxX: props.viewWidth - props.padding,\n  maxY: props.viewHeight - props.padding\n}))\n\n// Auto-draw animation logic\nconst lastLength = ref<number>(0) // Store the last path length for smooth transitions\n\nwatch(\n  () => props.data,\n  async (newData, oldData) => {\n    // Ensure data is actually new and autoDraw is enabled\n    // Comparing stringified versions is a simple way to check deep equality for basic data structures\n    if (props.autoDraw && JSON.stringify(newData) !== JSON.stringify(oldData)) {\n      await nextTick() // Wait for the DOM to update\n\n      // Check if running in server environment or if pathRef is not yet available\n      if (typeof window === 'undefined' || !pathRef.value?.$el) {\n        return\n      }\n\n      const pathElement = pathRef.value.$el as SVGPathElement // Type assertion\n      const length = pathElement.getTotalLength()\n\n      if (!isNaN(length)) {\n        // Ensure length is a valid number\n        pathElement.style.transition = 'none'\n        pathElement.style.strokeDasharray = `${length} ${length}`\n        // Use lastLength.value for the offset, default to 0 if it's the first draw\n        pathElement.style.strokeDashoffset = Math.abs(length - (lastLength.value || 0)).toString()\n\n        // Force reflow to apply the initial state before transition\n        pathElement.getBoundingClientRect()\n\n        // Apply the transition\n        pathElement.style.transition = `stroke-dashoffset ${props.autoDrawDuration}ms ${props.autoDrawEasing}`\n        pathElement.style.strokeDashoffset = '0'\n\n        lastLength.value = length // Update last length\n      } else {\n        console.warn('VueTrend: Could not get path length for autoDraw animation.')\n      }\n    } else if (!props.autoDraw && pathRef.value?.$el) {\n      // Reset styles if autoDraw is turned off\n      const pathElement = pathRef.value.$el as SVGPathElement\n      pathElement.style.transition = ''\n      pathElement.style.strokeDasharray = ''\n      pathElement.style.strokeDashoffset = ''\n      lastLength.value = 0 // Reset last length\n    }\n  },\n  {\n    immediate: true, // Run the watcher immediately on component mount\n    deep: true // Watch for changes within the data array/objects\n  }\n)\n</script>\n","import type { App, Plugin } from 'vue'\nimport VueTrendComponent from './components/VueTrend.vue'\n\nconst install: Plugin = (app: App) => {\n  app.component('VueTrend', VueTrendComponent)\n}\n\n// Attach the install function directly to the component object.\n// Use a type assertion with an intersection type to inform TypeScript\n// that this object now also has an 'install' property.\nconst VueTrend = VueTrendComponent as typeof VueTrendComponent & { install: Plugin }\nVueTrend.install = install\n\nexport default VueTrend\n"],"names":["int","value","checkCollinear","p0","p1","p2","getDistance","moveTo","to","from","radius","vector","length","unitVector","genPoints","arr","minX","minY","maxX","maxY","max","min","values","item","minValue","maxValue","gridX","gridY","safeGridY","index","genPath","points","pts","start","point","next","prev","isCollinear","threshold","radiusForPoint","before","after","props","__props","reversedGradient","computed","x1","y1","x2","y2","calculateOffset","len","pathData","strokeUrl","pathRef","ref","gradientId","boundary","lastLength","watch","newData","oldData","nextTick","_a","pathElement","_b","install","app","VueTrendComponent","VueTrend"],"mappings":"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"}